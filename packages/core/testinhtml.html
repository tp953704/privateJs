<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        const a = {
            Private:{
                
                cm:18.8
            },
            Public:{
                age:18,
                name:'Evan',
                say:function(){
                    // console.log(this.age)
                    return this.age;
                }
            }
        }
        function OOClass(Params){
            const { Private,Public } = Params;
            const newObj = Object.create(null);
            for(let key in Private){
                newObj[`_${key}`]=Private[key];
            }
            for(let key in Public){
                newObj[`${key}`]=Public[key];
            }
            return newObj;
        }
        const Person = OOClass(a)
        const privateHandler = {
            get:function (target, propKey, receiver) {
                propKey = realPropKey(target,propKey);
                if(!Reflect.has(target, 'isCallBySelf')){
                    if(propKey.startsWith('_')){
                        throw new TypeError("Cannot call a private element");
                    }
                    // console.log(Reflect.has(target, 'isCallBySelf'))
                    Reflect.set(target, 'isCallBySelf', true)
                }else{
                    Reflect.deleteProperty(target, 'isCallBySelf', true)
                }
                return Reflect.get(target, propKey, receiver);
            },
            set:function(target,propKey,value,receiver){
                if(propKey === 'isCallBySelf'){
                    throw new TypeError("Cannot set a isCallBySelf element");
                }
                
                return true;
            }
        }

        const privateBind = new Proxy(Person, privateHandler)
        
        console.log(privateBind.cm=5)
        function realPropKey(target,propKey){
            if(!Reflect.has(target, propKey)){
                console.log(propKey)
                if(!Reflect.has(target, `_${propKey}`)){
                    throw new TypeError(`there is no ${propKey} element`);
                }else{
                    console.log(Reflect.get(target, `_${propKey}`))
                    propKey = `_${propKey}`;
                }
            }
            return propKey;
        }
    
    
        // console.log(Person)


      
        const IsHasPropKey =(Class,propKey)=>{
            let privateProp = propKey;
            let publicProp = propKey;
            if(propKey.startsWith('_')){
                // 砍掉第一個字
                publicProp = propKey.substring(1,propKey.length)
            }else{
                privateProp = `_${propKey}`;
            }
            return Reflect.has(Class,publicProp) || Reflect.has(Class,privateProp);
        }
       
     
        
        
    </script>
</body>
</html>