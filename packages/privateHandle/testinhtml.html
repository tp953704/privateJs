<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        const a = {
            Private:{
                
                cm:18.8
            },
            Public:{
                age:18,
                name:'Evan',
                say:function(){
                    // console.log(this.age)
                    return this.age;
                }
            }
        }
        function OOClass(Params){
            const { Private,Public } = Params;
            const newObj = Object.create(null);
            for(let key in Private){
                newObj[`_${key}`]=Private[key];
            }
            for(let key in Public){
                newObj[`${key}`]=Public[key];
            }
            return newObj;
        }
        const Person = OOClass(a)
        const privateHandler = {
            get:function (target, propKey, receiver) {
                propKey = realPropKey(target,propKey);
                if(!Reflect.has(target, 'isCallBySelf')){
                    if(propKey.startsWith('_')){
                        throw new TypeError("Cannot call a private element");
                    }
                    // console.log(Reflect.has(target, 'isCallBySelf'))
                    Reflect.set(target, 'isCallBySelf', true)
                }else{
                    Reflect.deleteProperty(target, 'isCallBySelf', true)
                }
                return Reflect.get(target, propKey, receiver);
            },
            set:function(target,propKey,value,receiver){
                if(Reflect.has(target,propKey)){
                    console.log([target,propKey])
                    if(propKey.startsWith('_')){
                        console.log(Reflect.has(target, 'isCallBySelf'))
                    }
                }
                
            }
        }

        const privateBind = new Proxy(Person, privateHandler)
        // privateBind._age;
        // console.log(privateBind.say())
        function realPropKey(target,propKey){
            if(!Reflect.has(target, propKey)){
                console.log(propKey)
                if(!Reflect.has(target, `_${propKey}`)){
                    throw new TypeError(`there is no ${propKey} element`);
                }else{
                    console.log(Reflect.get(target, `_${propKey}`))
                    propKey = `_${propKey}`;
                }
            }
            return propKey;
        }
        console.log(Person)

        const IsHasPropKey =(Class,propKey)=>{
            let privateProp = propKey;
            let publicProp = propKey;
            if(propKey.startsWith('_')){
                // 砍掉第一個字
                publicProp = propKey.substring(1,propKey.length)
            }else{
                privateProp = `_${propKey}`;
            }
            return Reflect.has(Class,publicProp) || Reflect.has(Class,privateProp);
        }
        const IsHasPropKey1 =(propKeyAll,propKey)=>{
            let privateProp = propKey;
            let publicProp = propKey;
            if(propKey.startsWith('_')){
                // 砍掉第一個字
                publicProp = propKey.substring(1,propKey.length)
            }else{
                privateProp = `_${propKey}`;
            }
            console.log(propKeyAll,propKey)
            return propKeyAll.has(publicProp) || propKeyAll.has(privateProp);
        }
        function PropManager(OOPClass){
            this.model = OOPClass;
            this.key=new Set();
        }
        PropManager.prototype.mount = function(){
            const cModel = this.model;
            for(let key in cModel){
                this.key.add(key)
                console.log(key)
            }
        }
        const propManager = new PropManager(Person);
        propManager.mount()
        
    </script>
</body>
</html>